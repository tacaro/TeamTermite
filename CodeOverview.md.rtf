{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww16280\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Everything is run from run_and_tumble_mod2.m\
Most parameters that could be varied are declared at the top of run_and_tumble_mod2\
\
After declaring variables, the script begins by creating an x-y array of fertilizer mound locations. The mounds can be in either a random or uniform (grid) pattern. The landscape is created by calling initialize_landscape_1 given x and y dimensions, the location of fertilizer mounds, and the amount of grass that starts on top of a mound.. The x and y dimensions can be varied, although as of now they need to be equal for some code in run_and_tumble to run properly. The landscape has 3 layers: grass quantity (which decreases when it is eaten), nutrition (which currently does not change), and dung (which tracks how much time animals have spent in the given grid square). Dung increases when an animal is grazing and also along its movement path, proportional to the portion of the path that passed through that square. If the largest step an animal could take is 5, then there is a boundary such that any animal coming within 5 grid spaces of the edge of the landscape will disappear.\
\
The \'93trajectories\'94 array keeps track of the movement of all animals in a simulation. The first two columns are the first animal\'92s x and y coordinates, the next two columns are the second animal\'92s coordinates, etc.\
\
After the landscape is initialized, the simulation consists of 2 nested for loops. The outer for loop runs for the number of animals declared for the model. An animal is given a random starting position around the inner boundary, and a random starting direction away from the boundary region. The inner for loop runs for a set number of steps (unless the animal leaves the boundary). Each step, the animal checks the grass quantity and nutrition value at its current location. It uses some combination of these values and/or its fullness to decide whether to stay. Fullness starts at some initial quantity for each animal and decreases by some amount each turn. It increases as the animals eat.\
If the animal does not stay, it decides an angle and distance to move, and calculates an endpoint. The angle is chosen by uniform distribution which is narrower if the animal is \'93running\'94 and larger if \'93tumbling\'94. The distance is chosen by uniform distribution over larger values if \'93running\'94 and smaller values if \'93tumbling\'94. The decisions to run or tumble for distance and turning angle are determined by some combination of grass quantity, nutrition, and fullness.\
The script now calls \'93move_and_feed_1\'94. This function updates grass and dung quantities on the landscape from the animal\'92s motion and returns the amount of grass consumed and nutrition of the animal\'92s stopping spot. The animal can move on a finer scale than that of the landscape grid. This function creates a path based on the endpoints using move_1.m. It then checks (using check_path) if that path crosses any patches where the animal should stop. This again is determined by some combination of grass quantity, nutrition, and fullness. If the animal stops, its new stopping point will be passed back to run_and_tumble_mod2 so everything is in sync. check_path also checks if the animal leaves the boundary area. If it does, that information is passed back to run_and_tumble_mod2.\
Back in run_and_tumble_mod2, if the animal has left, then the inner for loop breaks, and we move to the next animal. All remaining values in the animal\'92s columns of the trajectories array are NaN. If the animal did not leave, its fullness is updated, and new location added to the trajectories array, and the inner (step) loop iterates again.\
\
Data collection and visualization:\
Lots of stuff!\
\
Some things that could be varied in functions outside of parameters at top of run_and_tumble:\
-Whether there are fertilizer patches on the edge of the boundary region for the uniform pattern in run_and-tumble_mod2 (code is written and can just be commented out)\
-The boolean for deciding to stop on a good patch along a path in check_path.m (make sure that the function has the required inputs!)\
-The boolean for deciding to stay (not move) during a turn in run_and_tumble_mod2\
-The boolean for deciding what turning range is in run_and_tumble_mod2\
-The boolean for deciding what movement distance range is in run_and_tumble_mod2\
-The equation that determines how grass_quantity and nutrition decrease with distance from a fertilizer mound.\
-Should energy spent always be the same, or vary if stay vs. tumble vs. run?\
\
}